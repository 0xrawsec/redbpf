// Copyright 2019 Authors of Red Sift
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

/*!
KProbes

KProbes are hooks on the entry (kprobe) or exit (kretprobe) of a kernel function.
For an overview of KProbes and how they work, see
<https://www.kernel.org/doc/Documentation/kprobes.txt>.

# Example

Do something when `execve` is called.

```
#![no_std]
#![no_main]
use redbpf_probes::bindings::*;
use redbpf_probes::kprobe::*;
use redbpf_macros::{program, kprobe};

program!(0xFFFFFFFE, "GPL");

#[kprobe("__arm64_sys_execve")]
pub extern "C" fn enter_execve(ctx: *mut c_void) -> i32 {
    let regs = Registers::from(ctx);

    // do something here
    // ...

    0
}
```
 */

use crate::bindings::*;
use core::mem::{size_of, MaybeUninit};
use cty::*;
use redbpf_macros::helpers;

pub struct Registers {
    pub ctx: *mut pt_regs,
}

impl From<*mut c_void> for Registers {
    #[inline]
    fn from(ptr: *mut c_void) -> Registers {
        Registers {
            ctx: (ptr as *mut pt_regs),
        }
    }
}

/// Allows you to access a field in the context to read it into the
/// stack
///
/// # Example
///
///     let socket = res.parm1() as *const sock;
///     let daddr = read_pointer::<in6_addr>(ctx_field!(socket.__sk_common.skc_v6_daddr));
#[macro_export]
macro_rules! ctx_field {
    ( $x:tt $(.$f:tt)* ) => {
	unsafe { &(*$x)$(.$f)* as *const _ as *const c_void }
    }
}

#[inline]
#[helpers]
pub fn read_pointer<T>(src: *const c_void) -> T {
    unsafe {
        let mut v: MaybeUninit<T> = MaybeUninit::uninit();
        bpf_probe_read(v.as_mut_ptr() as *mut c_void, size_of::<T>() as u32, src);

        v.assume_init()
    }
}

/// Convenience functions wrapping the architecture native `struct pt_regs`
///
/// These methods are ports of the [`PT_REGS_*`](https://elixir.bootlin.com/linux/v5.0/source/tools/testing/selftests/bpf/bpf_helpers.h#L270) macros in the Linux kernel.
///
/// The only supported architectures by RedBPF are aarch64/arm64 and
/// x86_64, therefore we only return 64bit registers, as generated by
/// bindgen.
impl Registers {
    /// First parameter to the function
    #[inline]
    pub fn parm1(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).di
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).regs[0]
        }
    }

    /// Second parameter to the function
    #[inline]
    pub fn parm2(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).si
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).regs[1]
        }
    }

    /// Third parameter to the function
    #[inline]
    pub fn parm3(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).dx
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).regs[2]
        }
    }

    /// Fourth parameter to the function
    #[inline]
    pub fn parm4(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).cx
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).regs[3]
        }
    }

    /// Fifth parameter to the function
    #[inline]
    pub fn parm5(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).r8
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).regs[4]
        }
    }

    /// Procedure link pointer (return to this IP)
    #[inline]
    pub fn ret(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).sp
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).regs[30]
        }
    }

    /// Frame pointer
    #[inline]
    pub fn fp(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).bp
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).regs[29]
        }
    }

    /// Return value
    #[inline]
    pub fn rc(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).ax
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).regs[0]
        }
    }

    /// Stack pointer
    #[inline]
    pub fn sp(&self) -> u64 {
        unsafe { (*self.ctx).sp }
    }

    /// Instruction pointer
    #[inline]
    pub fn ip(&self) -> u64 {
        #[cfg(target_arch = "x86_64")]
        unsafe {
            (*self.ctx).ip
        }

        #[cfg(target_arch = "aarch64")]
        unsafe {
            (*self.ctx).pc
        }
    }
}
